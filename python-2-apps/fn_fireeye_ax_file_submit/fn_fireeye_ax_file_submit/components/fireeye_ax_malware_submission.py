# -*- coding: utf-8 -*-
# pragma pylint: disable=unused-argument, no-self-use
"""Function implementation"""

import logging
from resilient_circuits import ResilientComponent, function, handler, StatusMessage, FunctionResult, FunctionError
import fn_fireeye_ax_file_submit.util.selftest as selftest
import requests
from resilient_lib import get_file_attachment, get_file_attachment_name
import tempfile
import shutil
import xmltodict
import json


class FunctionComponent(ResilientComponent):
    """Component that implements Resilient function 'fireeye_ax_malware_submission"""

    def __init__(self, opts):
        """constructor provides access to the configuration options"""
        super(FunctionComponent, self).__init__(opts)
        self.options = opts.get("fn_fireeye_ax_file_submit", {})
        selftest.selftest_function(opts)

    @handler("reload")
    def _reload(self, event, opts):
        """Configuration options have changed, save new values"""
        self.options = opts.get("fn_fireeye_ax_file_submit", {})

    @function("fireeye_ax_malware_submission")
    def _fireeye_ax_malware_submission_function(self, event, *args, **kwargs):
        """Function: This function submits a file to the FireEye AX appliance for inspection and then returns the results of that inspection back to the incident."""

        # - method that retreives specific attributes needed for the function to run like credentials, etc...
        def get_config_option(option_name, optional=False):
            """Given option_name, checks if it is in app.config. Raises ValueError if a mandatory option is missing"""
            option = self.options.get(option_name)

            if option is None and optional is False:
                err = "'{0}' is mandatory and is not set in app.config file. You must set this value to run this function".format(
                    option_name)
                raise ValueError(err)
            else:
                return option

        # Authentication specific settings
        user_name = get_config_option("user_name")
        password = get_config_option("user_credentials")
        host = get_config_option("endpoint")
        port = get_config_option("port")
        version = get_config_option("version")
        cert = get_config_option("verify_cert")

        # submission specific settings
        application = get_config_option("application")
        timeout = get_config_option("timeout")
        priority = get_config_option("priority")
        profiles = get_config_option("profiles")
        analysis_type = get_config_option("analysis_type")
        force = get_config_option("force")
        prefetch = get_config_option("prefetch")


        res_client = self.rest_client()
        fireeye_return = ''
        completion = False

        try:
            # Get the function parameters:
            incident_id = kwargs.get("incident_id")  # number
            artifact_id = kwargs.get("artifact_id")  # number
            artifact_type = kwargs.get("artifact_type")  # text

            log = logging.getLogger(__name__)
            log.info("incident_id: %s", incident_id)
            log.info("artifact_id: %s", artifact_id)
            log.info("artifact_type: %s", artifact_type)

            # PUT YOUR FUNCTION IMPLEMENTATION CODE HERE
            yield StatusMessage("starting...")


            # # Needed in the event that one does not know their profile
            # config_headers = {
            #     'X-FeApi-Token': '{}'.format(api),
            # }
            # # TODO: convert this to json from xml extract the profiles value
            # config_response = requests.get('https://{}:8443/wsapis/{}/config'.format(host, version),
            #                                             headers=config_headers, verify=False)
            # # print out to see what comes back for troubleshooting
            # log.info(config_response)



            # Generate X-FeApi-Token using the user name and creds
            login_response = requests.post('https://{}:{}/wsapis/{}/auth/login'.format(host,port,version), verify=False,
                                     auth=('{}'.format(user_name), '{}'.format(password)))

            log.info(login_response.headers)
            print(login_response.headers)

            header_results = login_response.headers

            log.info(header_results["Content-Length"])

            # This extracts the header object key and assign the variable to
            # the API Token
            api_token = header_results["X-FeApi-Token"]

            log.info(api_token)

            # Gets the Header
            headers = {
                'X-FeApi-Token': '{}'.format(api_token),
            }

            # pull down the contents of the file, assign path and open it
            artifact_file = get_file_attachment(res_client=res_client, incident_id=incident_id, artifact_id=artifact_id, task_id=None, attachment_id=None)

            # get name of the corresponding file content
            artifact_file_name = get_file_attachment_name(res_client=res_client, incident_id=incident_id, artifact_id=artifact_id, task_id=None, attachment_id=None)

            temp = tempfile.NamedTemporaryFile()

            try:
                temp.write(artifact_file)
                temp.seek(0)

                # This should copy the name of the temp file at the directory and give it the actual corresponding name of the artifact itself
                shutil.copy(temp.name,'{}'.format(artifact_file_name))

                # troubleshoot to make sure the name of the temp file is what it should be
                log.info(temp.name)


                # this is the payload for how the file should be represented
                payload = {'filename': temp.name,
                           'options': '{"application":"%s","timeout":"%s","priority":"%s","profiles":["%s"],'
                                      '"analysistype":"%s", "force":"%s","prefetch":"%s"}' % (
                                          application, timeout, priority, profiles, analysis_type, force,
                                          prefetch)}


                # This takes in the parameters from the header and file variables and returns a json object
                # The submission id needs to be extracted from the json object and assigned to a variable
                with open(temp.name, 'rb') as file_content:
                    submitted_file = {
                        'file': file_content
                    }
                    submission_response = requests.post(
                    'https://{}:{}/wsapis/{}/submissions/file'.format(host, port, version), headers=headers, data=payload, files=submitted_file, verify=False)

                log.info(submission_response)
                log.info(submission_response.content)

                submission_response_object = submission_response.content

                print(type(submission_response_object))
                submission_response_json = json.loads(submission_response_object)
                log.info(submission_response_json)

                print(json.dumps(submission_response_json, indent=4, sort_keys=True))

                submission_response_id = submission_response_json[0]["ID"]

                log.info(submission_response_id)

                params = (
                    ('info_level','extended'),
                )

                # This takes in the file submission id and returns the result of the file submission
                results_response = requests.get('https://{}:{}/wsapis/{}/submissions/results/()'.format(host,port,version,submission_response_id),
                                   headers=headers, params=params, verify=False)

                submission_results = results_response.content
                #submission_results = results_response.headers
                log.info(submission_results)

                # Returned results converted from xml to dictionary
                fireeye_results = json.dumps(xmltodict.parse(submission_results),indent=4)

                print(fireeye_results)

                fireeye_results_json = json.loads(fireeye_results)


                if 'submissionStatus' in fireeye_results_json:
                    fireeye_return = fireeye_results_json['submissionStatus']['submissionStatus']
                    completion = False
                elif 'alerts' in fireeye_results_json:
                    fireeye_results_object = {
                        "file_name": artifact_file_name,
                        "severity" : fireeye_results_json['alerts']['ns2:alert']['@severity'],
                        "is_it_malicious": fireeye_results_json['alerts']['@ans2:alert']['@malicious']
                    }

                    fireeye_return = fireeye_results_object
                else:
                    fireeye_return = "something went wrong..."
            finally:
                temp.close()

            yield StatusMessage("done...")

            # TODO: set this to actual output that will later be used for submission result return.
            results = {
                "value": fireeye_return,
                "payload": fireeye_results,
                "success": completion
            }

            # Produce a FunctionResult with the results
            yield FunctionResult(results)
        except Exception:
            yield FunctionError()