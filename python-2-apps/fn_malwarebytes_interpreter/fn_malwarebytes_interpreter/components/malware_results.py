# -*- coding: utf-8 -*-
# pragma pylint: disable=unused-argument, no-self-use
"""Function implementation"""

import logging
from resilient_circuits import ResilientComponent, function, handler, StatusMessage, FunctionResult, FunctionError
import fn_malwarebytes_interpreter.util.selftest as selftest
import sys
import datetime
import xml.etree.ElementTree as ET
from resilient_lib import get_file_attachment
import tempfile
from collections import defaultdict

class FunctionComponent(ResilientComponent):
    """Component that implements Resilient function 'malware_results"""

    def __init__(self, opts):
        """constructor provides access to the configuration options"""
        super(FunctionComponent, self).__init__(opts)
        self.options = opts.get("fn_malwarebytes_interpreter", {})
        selftest.selftest_function(opts)

    @handler("reload")
    def _reload(self, event, opts):
        """Configuration options have changed, save new values"""
        self.options = opts.get("fn_malwarebytes_interpreter", {})

    @function("malware_results")
    def _malware_results_function(self, event, *args, **kwargs):
        """Function: This function takes the .xml file results from Malwarebytes and returns the results to a data table."""

        res_client = self.rest_client()

        try:
            # Get the function parameters:
            incident_id = kwargs.get("incident_id")  # number
            attachment_id = kwargs.get("attachment_id")  # number
            artifact_id = kwargs.get("artifact_id")  # number

            log = logging.getLogger(__name__)
            log.info("incident_id: %s", incident_id)
            log.info("attachment_id: %s", attachment_id)
            log.info("artifact_id: %s", artifact_id)

            status = False

            # PUT YOUR FUNCTION IMPLEMENTATION CODE HERE
            yield StatusMessage("starting...")

            def scanfile_file():

                dict_list = list()
                file_objects = list()

                # # This code prints all of the Elements from the "Keys" <key> section.
                # for items in root.iter('key'):
                #     print("\n*-*-*-*-*Registry Key Item*-*-*-*-*\n")
                #     for child in items:
                #         print(child.tag, ":", child.text)
                #
                # # This code prints all of the Elements from the "Items" <value> section.
                # for items in root.iter('value'):
                #     print("\n*-*-*-*-*Line Item*-*-*-*-*\n")
                #     for child in items:
                #         print(child.tag, ":", child.text)
                #
                # # This code prints all of the Elements from the "Data" <data> section.
                # for items in root.iter('data'):
                #     print("\n*-*-*-*-*Data Item*-*-*-*-*\n")
                #     for child in items:
                #         print(child.tag, ":", child.text)
                #
                # # This code prints all of the Elements from the "Folders" <folder> section.
                # for items in root.iter('folder'):
                #     print("\n*-*-*-*-*Folder Item*-*-*-*-*\n")
                #     for child in items:
                #         print(child.tag, ":", child.text)


                # This code prints all of the Elements from the "Items" <file> section.
                # This takes the individual fields and throws them in a list of dictionary objects
                for items in root.iter('file'):
                    #print("\n*-*-*-*-*File Item*-*-*-*-*\n")
                    for child in items:
                        # print(child.tag, ":", child.text)
                        test_object = {
                            child.tag: child.text,
                        }
                        dict_list.append(test_object)
                        # print(test_object)



                # Observing that we care about 4 fields and the fact that
                # the dictiionary list contains 4 times the amount of individual elements,
                # this maps the four key value pairs and creates the object and adds it to a list
                # of file objects.
                i = 0
                while i < len(dict_list):
                    file_object = {
                        'path': dict_list[i]['path'],
                        'vendor': dict_list[i + 1]['vendor'],
                        'action': dict_list[i + 2]['action'],
                        'hash': dict_list[i + 3]['hash']
                    }
                    file_objects.append(file_object)
                    i += len(root.find('items'))

                print(file_objects)
                malwarebytes_object = file_objects

                # Experiment with creating a super dict.
                # super_dict = defaultdict(list)

                # for d in dict_list:
                #     for k,v in d.iteritems():
                #         super_dict[k].append(v)
                #
                # print(super_dict)

                # Marks the end of the scan.
                print("\n*-*-*-*-*End of Items*-*-*-*-*")
                print("\nTotal number of items found:", len(root.find('items')))


                malwarebytes_file = malwarebytes_object

                return malwarebytes_file



            def scanfile_system():

                dict_list = list()
                file_objects = list()

                # Checks system information
                print("\nSystem Information:")
                print(root[2][0].text, root[2][1].text, root[2][2].text)
                print("User running scan: ", root[2][4].text)
                print("\nTodays date is: ", datetime.date.today())
                print("\nDate this scan was ran: ", root[0][0].text)

                # Check if ran as admin.
                if root[0][2].text == 'yes':
                    print("\nThe scan was run as an admin.")
                else:
                    print("\n!-!-!-!-!-The scan WAS NOT run as an admin.-!-!-!-!-!")

                # Check if MWB is up to date.
                if root[1][0].text >= '2.7.0.1623':
                    print("\nMalwarebytes version is acceptable.", root[1][0].text)
                else:
                    print("\n!-!-!-!-!-Malwarebytes version is unacceptable.-!-!-!-!-!", root[1][0].text)

                # Check if scan was completed.
                if root[3][1].text == 'completed':
                    print("\nScan was completed successfully.")
                else:
                    print("\n!-!-!-!-!-Scan was NOT COMPLETED-!-!-!-!-!")

                # Check if rootkit scans were activated.
                if root[4][4].text == 'enabled':
                    print("\nRootkits were enabled.")
                else:
                    print("\n!-!-!-!-!-Rootkits were NOT ENABLED.-!-!-!-!-!")


                # This code prints all of the Elements from the "Items" <file> section.
                # This takes the individual fields and throws them in a list of dictionary objects
                for items in root.iter('file'):
                    print("\n*-*-*-*-*File Item*-*-*-*-*\n")
                    print(items)
                    for child in items:
                        #print(child.tag, ":", child.text)
                        test_object = {
                            child.tag: child.text,
                        }
                        dict_list.append(test_object)
                        # print(test_object)



                # Creates a dictionary object to be returned by the scan function
                malwarebytes_object = {
                    'machine_os': root[2][2].text,
                    'scan_user': root[2][4].text,
                    'scan_date': root[0][0].text,
                    'scan_as_admin': root[0][2].text,
                    'malwarebytes_version': root[1][0].text,
                    'scan_status': root[3][1].text,
                    'rookit_status': root[4][4].text,
                    'items_found': len(root.find('items'))
                }

                malwarebytes_system = malwarebytes_object

                return malwarebytes_system

            # This obtains the content from the attached file and assigns it to a variable to be parsed
            attachment_file = get_file_attachment(res_client=res_client, incident_id=incident_id, artifact_id=None,
                                                      task_id=None, attachment_id=attachment_id)

            temp = tempfile.NamedTemporaryFile()

            try:
                temp.write(attachment_file)
                temp.seek(0)

                # Parses the file.
                tree = ET.parse(temp)

                # Determines the root Element of the file.
                root = tree.getroot()
                m_system = scanfile_system()
                m_file = scanfile_file()
                if not m_file:
                    status = True

            finally:
                temp.close()

            yield StatusMessage("done...")

            results = {
                "success": status,
                "system_results": m_system,
                "file_results": m_file
            }

            # Produce a FunctionResult with the results
            yield FunctionResult(results)
        except Exception:
            yield FunctionError()